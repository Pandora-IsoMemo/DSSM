#' PlotSeriesExport Class
#'
#' This class is used to manage the export of a series of plots generated by a plotting function.
#' It allows for the generation of plots at specified time points, saving them in various formats,
#' and exporting them as a series of files or a GIF.
#'
#' @param plotFun A function that generates a plot given a model and a time point.
#' @param Model The model object that the plotting function will use.
#' @param times A vector of time points at which to generate the plots.
#' @param exportType The type of file to export the plots as (e.g., "png", "jpeg", "pdf", etc.).
#' @param modelType A string indicating the type of model (e.g., "local-average", "spread", etc.) for naming conventions.
#' @param width The width of the exported plots in pixels.
#' @param height The height of the exported plots in pixels.
#'
#' @export
new_PlotSeriesExport <- function(plotFun,
                                 Model,
                                 times,
                                 exportType = "png",
                                 modelType = "",
                                 # e.g. "local-average", "spread", ...
                                 width = 1280,
                                 height = 800) {
  stopifnot(is.function(plotFun))
  stopifnot(length(times) > 0)

  tmpDir <- tempfile("plot_export_")
  dir.create(tmpDir, recursive = TRUE)

  # Define static subfolders
  graphicFolder <- file.path(tmpDir, "graphic_export")
  maprFolder <- file.path(tmpDir, "mapr_export")

  dir.create(graphicFolder,
             showWarnings = FALSE,
             recursive = TRUE)
  dir.create(maprFolder, showWarnings = FALSE, recursive = TRUE)

  # Consistent filenames (no folder) â†’ only the basename like "myplot_1000.png"
  baseNames <- vapply(times, function(i)
    getFileName(modelType, TRUE, i), character(1))
  names(baseNames) <- times

  # Full paths
  pngFileNames <- file.path(maprFolder, paste0(baseNames, ".png"))
  names(pngFileNames) <- times

  fileExt <- ifelse(exportType == "geo-tiff", "tif", exportType)
  mainFileNames <- file.path(graphicFolder, paste0(baseNames, ".", fileExt))
  names(mainFileNames) <- times

  structure(
    list(
      path = tmpDir,
      times = times,
      baseNames = baseNames,
      pngFileNames = pngFileNames,
      mainFileNames = mainFileNames,
      plotFun = plotFun,
      Model = Model,
      exportType = exportType,
      width = width,
      height = height,
      status = "initialized",
      error = NULL
    ),
    class = "PlotSeriesExport"
  )
}

#' Print method for PlotSeriesExport objects
#' This method provides a summary of the PlotSeriesExport object.
#' @param x A PlotSeriesExport object.
#' @param ... Additional arguments (not used).
#'
#' @export
print.PlotSeriesExport <- function(x, ...) {
  cat("PlotSeriesExport object\n")
  cat("Status: ", x$status, "\n")
  cat("Path: ", x$path, "\n")
  cat("Export type: ", x$exportType, "\n")
  cat("Time points: ", paste(x$times, collapse = ", "), "\n")
  cat("graphicFolder: ", dirname(x$mainFileNames[[1]]), "\n")
  cat("maprFolder: ", dirname(x$pngFileNames[[1]]), "\n")
  if (x$status == "error") {
    cat("Error: ", x$error, "\n")
  }
  invisible(x)
}

generate <- function(obj, ...) {
  UseMethod("generate")
}

cleanup <- function(obj, ...) {
  UseMethod("cleanup")
}

exportSeries <- function(obj, ...) {
  UseMethod("exportSeries")
}

exportMapR <- function(obj, ...) {
  UseMethod("exportMapR")
}

#' Generate the series of plots and save them to files
#' This function iterates over the specified time points,
#' calls the plotting function for each time point,
#' and saves the plots in the specified format.
#' @param obj A PlotSeriesExport object.
#' @param ... Additional arguments (not used).
#' @return The modified PlotSeriesExport object with updated status.
#'
#' @export
generate.PlotSeriesExport <- function(obj, ...) {
  stopifnot(inherits(obj, "PlotSeriesExport"))

  obj$status <- "running"

  n <- length(obj$times)
  inShiny <- !is.null(shiny::getDefaultReactiveDomain())

  for (i in seq_along(obj$times)) {
    time <- obj$times[[i]]

    # for debugging:
    #obj$plotFun(model = obj$Model, time = time)

    # Write both main and png versions
    writePlotSeriesFilePair(
      plotFun = obj$plotFun,
      model = obj$Model,
      time = time,
      mainFile = obj$mainFileNames[[as.character(time)]],
      pngFile = obj$pngFileNames[[as.character(time)]],
      exportType = obj$exportType,
      width = obj$width,
      height = obj$height
    )

    if (inShiny) {
      shiny::incProgress(1 / n, detail = paste("Time:", time))
    }
  }

  obj$status <- "completed"

  invisible(obj)
}

#' Clean up the PlotSeriesExport object
#'
#' This function removes the temporary directory created for the export,
#' and updates the status of the object.
#'
#' @param obj A PlotSeriesExport object.
#' @param ... Additional arguments (not used).
#' @return The modified PlotSeriesExport object with updated status.
#'
#' @export
cleanup.PlotSeriesExport <- function(obj, ...) {
  stopifnot(inherits(obj, "PlotSeriesExport"))
  if (dir.exists(obj$path)) {
    unlink(obj$path, recursive = TRUE)
    obj$status <- "cleaned"
  } else {
    obj$status <- "missing"
  }
  invisible(obj)
}

#' Export the series of plots to files or a GIF
#'
#' This function handles the export of the generated plots
#' to either a ZIP file or a GIF, depending on the specified type of series.
#'
#' @param obj A PlotSeriesExport object.
#' @param file The name of the output file (ZIP or GIF).
#' @param modelType A string indicating the type of model (e.g., "local-average", "spread", etc.) for naming conventions.
#' @param typeOfSeries A string indicating the type of series to export ("onlyZip", "onlyGif", or "gifAndZip").
#' @param fpsGif The frames per second for the GIF (default is 1).
#' @param reverseGif A boolean indicating whether to reverse the order of the GIF frames (default is FALSE).
#' @param ... Additional arguments (not used).
#' @return The modified PlotSeriesExport object with updated status.
#'
#' @export
exportSeries.PlotSeriesExport <- function(obj,
                                          file,
                                          modelType,
                                          typeOfSeries,
                                          fpsGif = 1,
                                          reverseGif = FALSE,
                                          ...) {
  times <- obj$times
  exportType <- obj$exportType
  fileNames <- obj$mainFileNames
  gifInputFiles <- obj$pngFileNames  # Use PNG files for GIF
  width <- obj$width
  height <- obj$height

  if (reverseGif && typeOfSeries != "onlyZip") {
    times <- rev(times)
    fileNames <- fileNames[as.character(times)]
    gifInputFiles <- gifInputFiles[as.character(times)]
  }

  switch(
    typeOfSeries,
    onlyZip = zipr(zipfile = file, files = fileNames),
    onlyGif = generateGif(
      gifFile = file,
      files = gifInputFiles,
      fps = fpsGif,
      width = width,
      height = height
    ),
    gifAndZip = {
      gifName <- paste0(modelType, ".gif")
      generateGif(
        gifFile = gifName,
        files = gifInputFiles,
        fps = fpsGif,
        width = width,
        height = height
      )
      zipr(zipfile = file, files = c(gifName, fileNames))
      unlink(gifName)
    }
  )

  # clean up? Better, keep files for different exports
  #cleanup(obj)
}

#' Export the series of plots for MapR
#'
#' This function exports the series of plots generated by the PlotSeriesExport object
#' to a ZIP file containing the images and a JSON file listing the images.
#'
#' @param obj A PlotSeriesExport object.
#' @param file The name of the output ZIP file.
#' @param input A reactive input object containing the group, variable, and measure names.
#' @param ... Additional arguments (not used).
#' @return The modified PlotSeriesExport object with updated status.
#'
#' @export
exportMapR.PlotSeriesExport <- function(obj, file, input, ...) {
  times <- obj$times
  fileNames <- obj$pngFileNames

  finalPaths <- sapply(times, function(i) {
    file.path(
      "data",
      gsub(" ", "", input$`mapr-group`),
      gsub(" ", "", input$`mapr-variable`),
      gsub(" ", "", input$`mapr-measure`),
      paste0(i, ".png")
    )
  })

  # create sub directories
  lapply(unique(dirname(finalPaths)),
         dir.create,
         recursive = TRUE,
         showWarnings = FALSE)

  # copy files to final paths
  mapply(file.copy,
         from = fileNames,
         to = finalPaths,
         overwrite = TRUE)

  json_list <- create_image_list_json(input, finalPaths, times)
  json_file <- "image_list.json"
  jsonlite::write_json(json_list, json_file, pretty = TRUE)

  # zip the files
  zip(file, files = c(json_file, finalPaths))

  file.remove(finalPaths)
  file.remove(json_file)
  unlink("data", recursive = TRUE)
}

# HELPERS -----------

create_image_list_json <- function(input, figFileNames, times) {
  image_list <- list(Selections = list(
    list(
      Group = input$`mapr-group`,
      Group_DOI = 1,
      Variable = list(
        list(
          Variable_name = input$`mapr-variable`,
          Variable_DOI = 1,
          Measure = list(
            list(
              Measure_name = input$`mapr-measure`,
              Measure_unit = input$`mapr-measureunit`,
              images = list()
            )
          )
        )
      )
    )
  ))

  for (image in figFileNames) {
    time <- as.character(times[[which(figFileNames == image)]])

    single_image <- list(
      x_display_value = time,
      file_type = "png",
      location_type = "local",
      address = gsub("data/", "", image)
    )

    # Add the images to the list
    image_list$Selections[[1]]$Variable[[1]]$Measure[[1]]$images <- append(image_list$Selections[[1]]$Variable[[1]]$Measure[[1]]$images,
                                                                           list(single_image))
  }

  image_list
}

# Generate GIF
#
# @param gifFile The gif file to create
# @param files a list of files, url's, or raster objects or bitmap arrays
# @param exportType (character) file type of exported plot
# @param fps frames per second
# @param width Width of the GIF in pixels
# @param height Height of the GIF in pixels
generateGif <- function(gifFile = "animated.gif",
                        files,
                        fps = 1,
                        width = 1280,
                        height = 800) {
  # Create the GIF from a vector of image paths
  gifski::gifski(
    png_files = files,
    gif_file = gifFile,
    width = width,
    height = height,
    delay = 1 / fps
  )
}


writePlotSeriesFilePair <- function(plotFun,
                                    model,
                                    time,
                                    mainFile,
                                    pngFile,
                                    exportType,
                                    width,
                                    height) {
  # Plot once into a temporary null device to record it <- NOT WORKING!!
  # It's only working inside downloadHandler, not in an observer beforehand
  #
  # grDevices::png(tempfile(fileext = ".png"), width = width, height = height)
  # plotFun(model = model, time = time) # execute the plotting function
  # recorded <- grDevices::recordPlot()
  # grDevices::dev.off()

  # Save always as PNG (for MapR/gif etc.) ----

  grDevices::png(pngFile, width = width, height = height)
  #replayPlot(recorded) # replayPlot() WILL NOT WORK HERE!!!
  res <- plotFun(model = model, time = time)
  grDevices::dev.off()
  #print(paste("pngFile:", (file.exists(pngFile))))  # Should be TRUE

  # Save in main export format ----

  # if exportType == "geo-tiff", save as GeoTIFF
  
  if (exportType == "geo-tiff") {
    writeGeoTiff(res$XPred, filename = mainFile)
    return(invisible())
  }
  # if exportType == "png", just copy the PNG file
  if (exportType == "png") {
    file.copy(pngFile, mainFile, overwrite = TRUE)
    return(invisible())
  }

  # if exportType is jpeg, pdf, tiff, svg, open the corresponding device
  # and plot again
  switch(
    exportType,
    jpeg = grDevices::jpeg(mainFile, width = width, height = height),
    pdf  = grDevices::pdf(mainFile, width = width / 72, height = height / 72),
    tiff = grDevices::tiff(mainFile, width = width, height = height),
    svg  = grDevices::svg(mainFile, width = width / 72, height = height / 72)
  )
  #replayPlot(recorded) # replayPlot() WILL NOT WORK HERE!!!
  plotFun(model = model, time = time)
  grDevices::dev.off()
  #print(paste("mainFile:", file.exists(mainFile)))  # Should be TRUE

  invisible()
}
