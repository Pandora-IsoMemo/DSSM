% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/01-estimateMap.R
\name{estimateMapKernel}
\alias{estimateMapKernel}
\title{Estimates spatial kernel density model}
\usage{
estimateMapKernel(
  data,
  Longitude,
  Latitude,
  center = c("Europe", "Pacific"),
  independent = NULL,
  CoordType = "decimal degrees",
  Weighting = NULL,
  clusterMethod = NULL,
  nClust = 5,
  nClustRange = c(2, 10),
  kMeansAlgo = "Hartigan-Wong",
  trimRatio = 0.05,
  restriction = c(-90, 90, -180, 180),
  nSim = 10,
  kdeType = "1"
)
}
\arguments{
\item{data}{data.frame: data}

\item{Longitude}{character: name of longitude variable}

\item{Latitude}{character: name of latitude variable}

\item{center}{(character) center to shift data to, either "Europe" or "Pacific"}

\item{independent}{character: name of presence/absence variable (optional)}

\item{CoordType}{character: type of longitude/latitude coordinates.
One of "decimal degrees", "degrees minutes seconds" and "degrees decimal minutes"}

\item{Weighting}{character: name of weighting variable}

\item{clusterMethod}{character: cluster method}

\item{nClust}{numeric: how many clusters}

\item{nClustRange}{numeric: range of potential mclust cluster}

\item{kMeansAlgo}{character: kmeans algorithm as in stats:kmeans}

\item{trimRatio}{numeric: proportion of observations to be trimmed by tclust}

\item{restriction}{numeric vector: spatially restricts model data 4 entries for latitude (min/max) and longitude(min/max)}

\item{nSim}{numeric: number of bootstrap samples}

\item{kdeType}{character: "1" for correlated bandwidth, "2" for diagonal bandwidth, "3" for diagonal, equal long/lat bandwidth}
}
\description{
Estimates spatial kernel density model
}
\examples{
\dontrun{
#load data
data <- readRDS(system.file("extData", "exampleData.Rds", package = "DSSM"))
# estimate model-map
map <- estimateMap(data = data, independent = "d13C", Longitude = "longitude",
Latitude = "latitude", Site = "site")
# Plot the map
plotMap(model = map)

# Alternative: use app
shiny::runApp(paste0(system.file(package = "DSSM"),"/app"))

}
}
